const { getRandomFromArray, spliceRandomFromArray } = require('./helpers');

/** Song list object-storage */
class SongList {
  /**
   * @param {Object<string, Array<Song>>} map - special object generated by "prepare" function
   * @returns SongList
   */
  constructor(map) {
    this._map = map;
    this._tmpMap = JSON.parse(JSON.stringify(map)); // clone map for save mutation
    this._totalDuration = 0;
    this._playlistDuration = 0;
    this._possiblePlaylist = [];
  }

  /**
   * Get new chained play list
   * @param {number} playlistLength - number of songs in new play list
   * @param {boolean} [duplicates] - if true song duplicates may be in playlist,
   * else - no duplicates, but list can be shorter than expected
   * @returns {Array<Song>} - new playlist
   */
  getPlaylist(playlistLength, duplicates = false) {
    const getSong = duplicates ? getRandomFromArray : spliceRandomFromArray;
    const startLetterSongs = getRandomFromArray(Object.keys(this._tmpMap));
    const firstSong = getSong(this._tmpMap[startLetterSongs]);
    const playlist = [firstSong];
    for (let i = 1; i < playlistLength; i++) {
      const map = this._tmpMap[playlist[i - 1].lastLetter] || [];
      const song = getSong(map);
      if (!song) {
        break;
      }
      playlist.push(song);
    }
    this._restoreMap();
    return playlist;
  }

  /**
   * Restore special object with songs
   * @private
   */
  _restoreMap() {
    this._tmpMap = JSON.parse(JSON.stringify(this._map));
  }

  /**
   * recursively fill play list until its duration is not bigger then expected duration
   * @param {Array<Song>} songs - songs starting on last letter of previous song
   * @private
   */
  _fillPlaylist(songs) {
    for (let i = 0; i < songs.length; i++) {
      const song = songs[i];
      if (this._totalDuration + song.duration > this._playlistDuration) {
        throw new Error('Duration is too long'); // stop recursion
      }
      this._totalDuration += song.duration;
      this._possiblePlaylist.push(song);
      songs.splice(i, 1);
      this._fillPlaylist(this._tmpMap[song.lastLetter]);
    }
  }

  /**
   * Get new play list with duration less or equal to duration from params
   * @private
   * @todo It is not well tested, and may not be used now
   * @param {number} duration - duration in ms of new playlist
   * @returns {Array<Song>} - new playlist
   */
  getPlaylistByDuration(duration) {
    this._playlistDuration = duration;
    const startLetterSongs = getRandomFromArray(Object.keys(this._tmpMap));
    const firstSong = getRandomFromArray(this._tmpMap[startLetterSongs]);
    this._possiblePlaylist = [firstSong];
    this._totalDuration = firstSong.duration;
    try {
      this._fillPlaylist(this._tmpMap[firstSong.lastLetter]);
    } catch (e) {
      if (e.message !== 'Duration is too long') {
        throw e;
      }
    }
    this._restoreMap();
    return this._possiblePlaylist;
  }
}

module.exports = SongList;
